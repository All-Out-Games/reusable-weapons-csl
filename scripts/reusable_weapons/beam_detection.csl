// Line beam: damage players along a line from origin in direction
beam_line_damage :: proc(player: Player, origin: v2, direction: v2, range: float, width: float, damage: float) {
    nearby: [..]Player;
    Scene.get_all_components_in_range(origin, range, ref nearby);

    dir := normalize(direction);

    for target: nearby {
        if target.entity.id == player.entity.id continue;
        if target.health <= 0 continue;

        target_pos := target.entity.world_position;
        to_target := v2{target_pos.x - origin.x, target_pos.y - origin.y};

        // Project onto beam direction
        dot := to_target.x * dir.x + to_target.y * dir.y;
        if dot < 0 || dot > range continue;

        // Perpendicular distance
        proj := v2{dir.x * dot, dir.y * dot};
        perp := v2{to_target.x - proj.x, to_target.y - proj.y};
        perp_dist := length(perp);

        if perp_dist <= width {
            target.health -= damage;
            if target.health < 0 {
                target.health = 0;
            }
        }
    }
}

// Cone beam: damage players within a cone from origin
beam_cone_damage :: proc(player: Player, origin: v2, direction: v2, range: float, cone_angle_deg: float, damage: float) {
    nearby: [..]Player;
    Scene.get_all_components_in_range(origin, range, ref nearby);

    dir := normalize(direction);
    half_angle := cone_angle_deg * 0.5 * 3.14159 / 180.0;

    for target: nearby {
        if target.entity.id == player.entity.id continue;
        if target.health <= 0 continue;

        target_pos := target.entity.world_position;
        to_target := v2{target_pos.x - origin.x, target_pos.y - origin.y};
        dist := length(to_target);
        if dist < 0.1 || dist > range continue;

        to_target_norm := normalize(to_target);

        dot := dir.x * to_target_norm.x + dir.y * to_target_norm.y;
        if dot > 1.0 { dot = 1.0; }
        if dot < -1.0 { dot = -1.0; }

        cos_half := cos(half_angle);

        if dot >= cos_half {
            target.health -= damage;
            if target.health < 0 {
                target.health = 0;
            }
        }
    }
}

// Radius-based damage: damages all players within range (Octo Siphoner)
beam_radius_damage :: proc(player: Player, origin: v2, range: float, damage: float) -> s64 {
    nearby: [..]Player;
    Scene.get_all_components_in_range(origin, range, ref nearby);
    hit_count: s64 = 0;
    for target: nearby {
        if target.entity.id == player.entity.id continue;
        if target.health <= 0 continue;
        target.health -= damage;
        if target.health < 0 { target.health = 0; }
        hit_count += 1;
    }
    return hit_count;
}

// Beam visual entity - positions spine beam between source and target each frame
Beam_Visual :: class : Component {
    owner_id: u64;
    target_id: u64;
    beam_range: float;

    ao_update :: method(dt: float) {
        spine_anim := entity->get_component(Spine_Animator);
        if spine_anim == null return;
        spine_anim->awaken();

        // Find source player
        source: Player;
        foreach p: component_iterator(Player) {
            if p.entity.id == owner_id {
                source = p;
                break;
            }
        }
        if source == null {
            if Game.is_server() { entity->destroy(); }
            return;
        }

        // Beam start from PROJECTILE bone
        bone_local := source.animator.instance->get_bone_local_position("PROJECTILE");
        barrel_dist := length(bone_local);
        aim_dir := source.last_aim_direction;
        start_pos := v2{source.animator.entity.world_position.x + aim_dir.x * barrel_dist, source.animator.entity.world_position.y + aim_dir.y * barrel_dist};

        end_pos: v2;
        if target_id != 0 {
            // Targeted beam (Octo Siphoner) - aim at specific player
            target: Player;
            foreach p: component_iterator(Player) {
                if p.entity.id == target_id {
                    target = p;
                    break;
                }
            }
            if target == null || target.health <= 0 {
                if Game.is_server() { entity->destroy(); }
                return;
            }
            end_pos = target.entity.world_position;
        } else {
            // Directional beam (Void Splitter) - aim in player's direction
            dir := source.last_aim_direction;
            end_pos = v2{start_pos.x + dir.x * beam_range, start_pos.y + dir.y * beam_range};
        }

        // Position beam bones (beam entity is at origin with unit scale, so world == local)
        spine_anim.instance->set_bone_local_position("beam_base", start_pos);
        spine_anim.instance->set_bone_local_position("AIM", end_pos);
    }
}

spawn_beam_entity :: proc(owner_id: u64, target_id: u64, skin_name: string, anim_name: string, beam_range: float) {
    beam_entity := Scene.create_entity();

    spine := beam_entity->add_component(Spine_Animator);
    spine->awaken();
    beam_asset := get_asset(Spine_Asset, "reusable_weapons/anims/reusable-weapons/lightning_beam/lighting_beam.spine");
    spine.instance->set_skeleton(beam_asset);
    spine.instance->enable_skin(skin_name);
    spine.instance->refresh_skins();
    spine.instance->set_animation(anim_name, true, 0);

    beam := beam_entity->add_component(Beam_Visual);
    beam.owner_id = owner_id;
    beam.target_id = target_id;
    beam.beam_range = beam_range;
}

destroy_player_beams :: proc(owner_id: u64) {
    foreach beam: component_iterator(Beam_Visual) {
        if beam.owner_id == owner_id {
            beam.entity->destroy();
        }
    }
}
