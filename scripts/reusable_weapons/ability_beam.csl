Beam_Ability :: class : Ability_Base {
    was_shooting: bool;
    beam_sound_id: u64;
    beams_spawned: bool;
    octo_loop_sound_id: u64;

    on_init :: proc(ability: Ability_Base) {
        ability.name = "Beam";
        ability.icon = get_asset(Texture_Asset, "sprites/reusable-weapons/weapon_icons/weapon_icons_250x250/fireray.png");
        ability.disable_keybind = true;
        ability.is_aimed_ability = true;
    }

    can_use :: proc(ability: Ability_Base) -> bool {
        p := ability.player.(Player);
        if p.equipped_weapon_type == .NONE return false;
        config := get_weapon_config(p.equipped_weapon_type);
        if config.fire_mode != .BEAM return false;
        return weapon_has_ammo(p, p.equipped_weapon_type);
    }

    on_update :: proc(ability: Ability_Base, params: ref Ability_Update_Params) {
        p := ability.player.(Player);
        self := ability.(Beam_Ability);
        wt := p.equipped_weapon_type;
        config := get_weapon_config(wt);

        ability.icon = get_asset(Texture_Asset, config.weapon_icon_path);

        aiming := Ability_Utilities.update_aiming_ability(p, ref params);

        if aiming.aim {
            p.last_aim_direction = aiming.aim_direction;
            p->set_mouse_ik_enabled(true);
            p->set_aim_target(p.entity.world_position + aiming.aim_direction * 5.0);
            draw_thin_aiming_line(p.entity.world_position, aiming.aim_direction, 1.0);
        } else {
            p->set_mouse_ik_enabled(false);
        }

        should_fire := false;
        if p.device_kind == .PC {
            should_fire = aiming.activate;
        } else {
            should_fire = aiming.aim;
        }

        if should_fire && params.can_use && ability.current_cooldown <= 0 {
            // Start beam animation on first fire
            if !self.was_shooting {
                weapon_start_shoot_anim(p, wt);
                weapon_play_fire_sound(p, wt);

                // Octo Siphoner: play start sound, then loop sound
                if wt == .OCTO_SIPHONER {
                    start_desc := SFX.default_sfx_desc();
                    start_desc.entity_to_follow = p.entity.id;
                    start_desc.volume = 0.7;
                    SFX.play(get_asset(SFX_Asset, "sounds/reusable-weapons/octosiphoner_start.wav"), start_desc);

                    loop_desc := SFX.default_sfx_desc();
                    loop_desc.entity_to_follow = p.entity.id;
                    loop_desc.volume = 0.5;
                    self.octo_loop_sound_id = SFX.play(get_asset(SFX_Asset, "sounds/reusable-weapons/octosiphoner_loop.wav"), loop_desc);
                }

                self.was_shooting = true;
            }

            // Consume ammo per tick
            if config.ammo_per_shot > 0 {
                weapon_consume_ammo(p, wt, config.ammo_per_shot);
            }

            // Server: damage detection and beam entity management
            if Game.is_server() {
                origin := p.entity.world_position;

                if wt == .OCTO_SIPHONER {
                    // Radius-based damage, heal scales with targets hit
                    destroy_player_beams(p.entity.id);
                    hit_count := beam_radius_damage(p, origin, config.beam_range, config.base_damage);

                    // Spawn beam entities for each target in range
                    nearby: [..]Player;
                    Scene.get_all_components_in_range(origin, config.beam_range, ref nearby);
                    beam_count := 0;
                    for target: nearby {
                        if target.entity.id == p.entity.id continue;
                        if target.health <= 0 continue;
                        if beam_count >= 5 break;
                        spawn_beam_entity(p.entity.id, target.entity.id, "pink", "pink_beam_loop_AL_mIK", config.beam_range);
                        beam_count += 1;
                    }

                    // Heal based on number of targets (scaled, max at 5 targets)
                    if config.heals_self && hit_count > 0 {
                        heal_scale := hit_count.(float);
                        if heal_scale > 5.0 { heal_scale = 5.0; }
                        heal := config.heal_amount * heal_scale / 5.0;
                        p.health += heal;
                        if p.health > p.max_health { p.health = p.max_health; }
                    }
                } else if wt == .VOID_SPLITTER {
                    // Line beam damage + single directional beam entity
                    beam_line_damage(p, origin, aiming.aim_direction, config.beam_range, config.beam_width, config.base_damage);

                    if !self.beams_spawned {
                        spawn_beam_entity(p.entity.id, 0, "blue", "lightning_beam_loop_AL_mIK", config.beam_range);
                        self.beams_spawned = true;
                    }
                } else {
                    // Fire Ray, Ice Launcher, Glaciator, Solar Siphoner
                    // Beam visual is part of weapon animation (animation-based beams)
                    if config.beam_cone_angle > 0 {
                        beam_cone_damage(p, origin, aiming.aim_direction, config.beam_range, config.beam_cone_angle, config.base_damage);
                    } else {
                        beam_line_damage(p, origin, aiming.aim_direction, config.beam_range, config.beam_width, config.base_damage);
                    }

                    if config.heals_self {
                        p.health += config.heal_amount;
                        if p.health > p.max_health { p.health = p.max_health; }
                    }
                }
            }

            ability.current_cooldown = config.fire_rate;
        }

        // Fire Ray: position BEAM_TARGET bone each frame for beam aiming
        if self.was_shooting && wt == .FIRE_RAY {
            dir := p.last_aim_direction;
            bone_local := p.animator.instance->get_bone_local_position("PROJECTILE");
            barrel_dist := length(bone_local);
            beam_start := v2{p.animator.entity.world_position.x + dir.x * barrel_dist, p.animator.entity.world_position.y + dir.y * barrel_dist};
            beam_end := v2{beam_start.x + dir.x * config.beam_range, beam_start.y + dir.y * config.beam_range};
            anim_scale := p.animator.entity.local_scale;
            beam_end_local := v2{(beam_end.x - p.animator.entity.world_position.x) / anim_scale.x, (beam_end.y - p.animator.entity.world_position.y) / anim_scale.x};
            p.animator.instance->set_bone_local_position("BEAM_TARGET", beam_end_local);
        }

        // Stop beam
        if !should_fire && self.was_shooting {
            weapon_stop_shoot_anim(p, wt);

            // Octo Siphoner: stop loop sound, play end sound
            if wt == .OCTO_SIPHONER {
                if self.octo_loop_sound_id != 0 {
                    SFX.stop(self.octo_loop_sound_id);
                    self.octo_loop_sound_id = 0;
                }
                end_desc := SFX.default_sfx_desc();
                end_desc.entity_to_follow = p.entity.id;
                end_desc.volume = 0.7;
                SFX.play(get_asset(SFX_Asset, "sounds/reusable-weapons/octosiphoner_end.wav"), end_desc);
            }

            self.was_shooting = false;
            self.beams_spawned = false;
            if Game.is_server() {
                destroy_player_beams(p.entity.id);
            }
        }

        // Out of ammo
        if should_fire && !weapon_has_ammo(p, wt) {
            if p->is_local() {
                Notifier.notify("Out of ammo!");
            }
            if self.was_shooting {
                weapon_stop_shoot_anim(p, wt);

                // Octo Siphoner: stop loop sound, play end sound
                if wt == .OCTO_SIPHONER {
                    if self.octo_loop_sound_id != 0 {
                        SFX.stop(self.octo_loop_sound_id);
                        self.octo_loop_sound_id = 0;
                    }
                    end_desc := SFX.default_sfx_desc();
                    end_desc.entity_to_follow = p.entity.id;
                    end_desc.volume = 0.7;
                    SFX.play(get_asset(SFX_Asset, "sounds/reusable-weapons/octosiphoner_end.wav"), end_desc);
                }

                self.was_shooting = false;
                self.beams_spawned = false;
                if Game.is_server() {
                    destroy_player_beams(p.entity.id);
                }
            }
        }
    }
}
