import "core:ao"
import "reusable_weapons"

Player :: class : Player_Base {
    health: float;
    max_health: float;
    equipped_weapon_type: Weapon_Type;
    equipped_item_def: Item_Definition;
    last_selected_index: s64;
    boomwheel_cannon: Boomwheel_Cannon;

    ao_start :: method() {
        health = 100.0;
        max_health = 100.0;
        last_selected_index = -1;

        if Game.is_server() {
            init_weapon_items();

            // Expand inventory to fit all weapons + ammo
            Items.set_capacity(default_inventory, 40);

            // Give all weapons
            give_weapon(.ASSAULT_RIFLE, default_inventory);
            give_weapon(.SUBMACHINE_GUN, default_inventory);
            give_weapon(.GATLING_GUN, default_inventory);
            give_weapon(.BEAM_MACHINE, default_inventory);
            give_weapon(.WATER_GUN, default_inventory);
            give_weapon(.MISSILE_BARRAGE, default_inventory);
            give_weapon(.BLUNDERBUSS, default_inventory);
            give_weapon(.RAY_GUN, default_inventory);
            give_weapon(.PLASMA_BURST, default_inventory);
            give_weapon(.MEGA_BLADE, default_inventory);
            give_weapon(.BUZZSHOT, default_inventory);
            give_weapon(.EXPLOSIVE_SHOTGUN, default_inventory);
            give_weapon(.SUNNY_SIDE_SHOTTY, default_inventory);
            give_weapon(.GOLDEN_ROCKET_LAUNCHER, default_inventory);
            give_weapon(.WATER_BALLOON_RPG, default_inventory);
            give_weapon(.POISON_GRENADE, default_inventory);
            give_weapon(.BOOMWHEEL, default_inventory);
            give_weapon(.FIRE_RAY, default_inventory);
            give_weapon(.ICE_LAUNCHER, default_inventory);
            give_weapon(.GLACIATOR, default_inventory);
            give_weapon(.SOLAR_SIPHONER, default_inventory);
            give_weapon(.OCTO_SIPHONER, default_inventory);
            give_weapon(.VOID_SPLITTER, default_inventory);
            give_weapon(.AKIMBO_PISTOLS, default_inventory);
            give_weapon(.WIND_BLASTER, default_inventory);
            give_weapon(.STORMS_EYE, default_inventory);
            give_weapon(.HYDRO_CANNON, default_inventory);

            // Give all ammo types
            i := 0;
            while i < AMMO_TYPE_COUNT {
                info := get_ammo_info(i);
                ammo_inst := Items.create_item_instance(g_ammo_item_defs[i], info.stack_size);
                Items.move_item_to_inventory(ammo_inst, default_inventory);
                i += 1;
            }
        }

        setup_weapon_animations(this);

        // Zoom out camera
        camera.size = 6.0;
    }

    ao_late_update :: method(dt: float) {
        if is_local_or_server() {
            // Draw fire ability based on equipped weapon's fire mode
            if equipped_weapon_type != .NONE {
                config := get_weapon_config(equipped_weapon_type);
                switch config.fire_mode {
                    case .CONTINUOUS:  { draw_ability_button(this, Continuous_Fire_Ability, 0); }
                    case .SINGLE_SHOT: { draw_ability_button(this, Single_Shot_Ability, 0); }
                    case .SPREAD:      { draw_ability_button(this, Spread_Shot_Ability, 0); }
                    case .LOBBED:      { draw_ability_button(this, Lobbed_Shot_Ability, 0); }
                    case .BEAM:        { draw_ability_button(this, Beam_Ability, 0); }
                    case .SPECIAL:     { draw_ability_button(this, Special_Ability, 0); }
                }
                // Always draw melee at index 1
                draw_ability_button(this, Melee_Ability, 1);
            }

            // Draw hotbar
            options := Inventory_Draw_Options.default();
            options.hotbar_item_count = 10;
            options.enable_selection = true;
            options.scroll_item_selection = true;
            options.keyboard_item_selection = true;
            options.enable_use_from_hotbar = false;

            hotbar := Items.draw_hotbar(this, default_inventory, options);

            // Show equipped weapon name above hotbar
            if equipped_weapon_type != .NONE {
                config := get_weapon_config(equipped_weapon_type);
                label_rect := hotbar.entire_rect->top_rect()->grow(20, 0, 0, 0);
                ts := UI.default_text_settings();
                ts.size = 36;
                ts.halign = .CENTER;
                ts.valign = .BOTTOM;
                ts.do_outline = true;
                ts.outline_thickness = 3;
                ts.outline_color = {0, 0, 0, 1};
                UI.text(label_rect, ts, config.item_name);
            }

            // Handle equip/unequip on selection change
            if hotbar.selected_item_index != last_selected_index {
                last_selected_index = hotbar.selected_item_index;

                selected_item: Item_Instance;
                if hotbar.selected_item_index >= 0 && hotbar.selected_item_index < default_inventory.capacity {
                    selected_item = default_inventory->get_item(hotbar.selected_item_index);
                }
                handle_equip_change(selected_item);
            }
        }

        // Draw health bar for all clients (skip server-only)
        if !Game.is_server() {
            draw_health_bar(this);
        }
    }

    handle_equip_change :: method(new_item: Item_Instance) {
        new_def: Item_Definition;
        if new_item != null {
            new_def = new_item->get_definition();
        }

        // Skip if same item definition
        if new_def == equipped_item_def return;

        // Unequip old weapon
        if equipped_weapon_type != .NONE {
            weapon_unequip(this, equipped_weapon_type);
            equipped_weapon_type = .NONE;
        }
        equipped_item_def = null;

        // Equip new weapon if it's a registered weapon
        if new_def != null {
            wt := get_weapon_type_for_item(new_def);
            if wt != .NONE {
                weapon_equip(this, wt);
                equipped_weapon_type = wt;
                equipped_item_def = new_def;
            }
        }
    }
}

draw_health_bar :: proc(player: Player) {
    UI.push_world_draw_context();
    defer UI.pop_draw_context();

    pos := player.entity.world_position;
    UI.push_z(pos.y - 0.0001);
    defer UI.pop_z();

    UI.push_scale_factor(5.0 / 540.0);
    defer UI.pop_scale_factor();

    health_rect := player.username_rect->top_center_rect()->offset(0, 5);
    health_rect = health_rect->grow(13, 70, 0, 70);
    border_rect := health_rect->grow(5.5, 4, 5.5, 4)->offset(0, -2);

    back := get_asset(Texture_Asset, "reusable_weapons/sprites/reusable-weapons/hud_elements/health_bar_green/healthbar_back.png");
    fill := get_asset(Texture_Asset, "reusable_weapons/sprites/reusable-weapons/hud_elements/health_bar_green/healthbar_fill.png");
    pip := get_asset(Texture_Asset, "reusable_weapons/sprites/reusable-weapons/hud_elements/health_bar_green/healthbar_pip.png");

    // Background
    UI.quad(border_rect, back, {1, 1, 1, 1});

    // Health fill
    health_pct := player.health / player.max_health;
    fill_rect := health_rect->subrect(0, 0, health_pct, 1);
    UI.quad(fill_rect, fill, {1, 1, 1, 1});

    // Pip markers
    total_pips :: 6;
    health_per_pip := player.max_health / total_pips.(float);
    left_offset :: 0.05;
    right_offset :: 0.05;
    available_width := 1.0 - left_offset - right_offset;
    pip_width := available_width / total_pips.(float);
    shrink :: 0.3;

    i := 0;
    while i < total_pips {
        pip_threshold := (i + 1).(float) * health_per_pip;
        if player.health >= pip_threshold {
            x_min := left_offset + i.(float) * pip_width;
            new_width := pip_width * shrink;
            new_x_min := x_min + (pip_width - new_width) / 2.0;
            new_x_max := new_x_min + new_width;
            pip_rect := health_rect->subrect(new_x_min, 0, new_x_max, 1);
            UI.quad(pip_rect, pip, {1, 1, 1, 1});
        }
        i += 1;
    }
}
